<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    
    <title>medpy.features.intensity &mdash; MedPy 0.3.0 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-bootstrap.css">
    <link rel="stylesheet" type="text/css" href="../../../_static/css/spc-extend.css">
    <link rel="stylesheet" href="../../../_static/scipy.css" type="text/css" >
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" >
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <link rel="top" title="MedPy 0.3.0 documentation" href="../../../index.html" >
    <link rel="up" title="Module code" href="../../index.html" > 
  </head>
  <body>

  <div class="container">
    <div class="header">
    </div>
  </div>


    <div class="container">
      <div class="main">
        
	<div class="row-fluid">
	  <div class="span12">
	    <div class="spc-navbar">
              
    <ul class="nav nav-pills pull-left">
        <li class="active"><a href="https://github.com/loli/medpy/">GitHub</a></li>
        <li class="active"><a href="https://pypi.python.org/pypi/MedPy/">PyPi</a></li>
        <li class="active"><a href="https://hub.docker.com/r/loli/medpy/">Docker</a></li>
	
        <li class="active"><a href="../../../index.html">MedPy 0.3.0 documentation</a></li>
	
          <li class="active"><a href="../../index.html" accesskey="U">Module code</a></li> 
    </ul>
              
              
    <ul class="nav nav-pills pull-right">
      <li class="active">
        <a href="../../../genindex.html" title="General Index"
           accesskey="I">index</a>
      </li>
      <li class="active">
        <a href="../../../py-modindex.html" title="Python Module Index"
           >modules</a>
      </li>
    </ul>
              
	    </div>
	  </div>
	</div>
        

	<div class="row-fluid">
      <div class="spc-rightsidebar span3">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
          <div class="span9">
            
        <div class="bodywrapper">
          <div class="body" id="spc-section-body">
            
  <h1>Source code for medpy.features.intensity</h1><div class="highlight"><pre>
<span class="c1"># Copyright (C) 2013 Oskar Maier</span>
<span class="c1"># </span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1"># </span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1"># </span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1"># author Oskar Maier</span>
<span class="c1"># version r0.3.3</span>
<span class="c1"># since 2013-08-24</span>
<span class="c1"># status Release</span>

<span class="c1"># build-in modules</span>

<span class="c1"># third-party modules</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">gaussian_filter</span><span class="p">,</span> <span class="n">median_filter</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.filters</span> <span class="kn">import</span> <span class="n">gaussian_gradient_magnitude</span> <span class="k">as</span> <span class="n">scipy_gaussian_gradient_magnitude</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">distance_transform_edt</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage._ni_support</span> <span class="kn">import</span> <span class="n">_get_output</span>

<span class="c1"># own modules</span>
<span class="kn">from</span> <span class="nn">.utilities</span> <span class="kn">import</span> <span class="n">join</span>
<span class="kn">from</span> <span class="nn">..core</span> <span class="kn">import</span> <span class="n">ArgumentError</span>
<span class="kn">from</span> <span class="nn">..filter</span> <span class="kn">import</span> <span class="n">sum_filter</span>

<span class="c1"># constants</span>

<div class="viewcode-block" id="intensities"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.intensities.html#medpy.features.intensity.intensities">[docs]</a><span class="k">def</span> <span class="nf">intensities</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;Takes a simple or multi-spectral image and returns its voxel-wise intensities.</span>
<span class="sd">    A multi-spectral image must be supplied as a list or tuple of its spectra.</span>
<span class="sd">    </span>
<span class="sd">    Optionally a binary mask can be supplied to select the voxels for which the feature</span>
<span class="sd">    should be extracted.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    intensities : ndarray</span>
<span class="sd">        The images intensities.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_intensities</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span></div>

<div class="viewcode-block" id="centerdistance"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.centerdistance.html#medpy.features.intensity.centerdistance">[docs]</a><span class="k">def</span> <span class="nf">centerdistance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Takes a simple or multi-spectral image and returns its voxel-wise center distance in</span>
<span class="sd">    mm. A multi-spectral image must be supplied as a list or tuple of its spectra.</span>
<span class="sd">    </span>
<span class="sd">    Optionally a binary mask can be supplied to select the voxels for which the feature</span>
<span class="sd">    should be extracted.</span>
<span class="sd">    </span>
<span class="sd">    The center distance is the exact euclidean distance in mm of each voxels center to</span>
<span class="sd">    the central point of the overal image volume.</span>
<span class="sd">    </span>
<span class="sd">    Note that this feature is independent of the actual image content, but depends</span>
<span class="sd">    solely on its shape. Therefore always a one-dimensional feature is returned, even if</span>
<span class="sd">    a multi-spectral image has been supplied. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centerdistance : ndarray</span>
<span class="sd">        The distance of each voxel to the images center.</span>
<span class="sd">        </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    centerdistance_xdminus1</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_centerdistance</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="n">voxelspacing</span><span class="p">)</span></div>

<div class="viewcode-block" id="centerdistance_xdminus1"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.centerdistance_xdminus1.html#medpy.features.intensity.centerdistance_xdminus1">[docs]</a><span class="k">def</span> <span class="nf">centerdistance_xdminus1</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Implementation of `centerdistance` that allows to compute sub-volume wise</span>
<span class="sd">    centerdistances.</span>
<span class="sd">    </span>
<span class="sd">    The same notes as for `centerdistance` apply.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    dim : int or sequence of ints</span>
<span class="sd">        The dimension or dimensions along which to cut the image into sub-volumes.</span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centerdistance_xdminus1 : ndarray</span>
<span class="sd">        The distance of each voxel to the images center in the supplied dimensions.</span>
<span class="sd">    </span>
<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ArgumentError</span>
<span class="sd">        If a invalid dim index of number of dim indices were supplied</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Considering a 3D medical image we want to compute the axial slice-wise</span>
<span class="sd">    centerdistances instead of the ones over the complete image volume. Assuming that</span>
<span class="sd">    the third image dimension corresponds to the axial axes of the image, we call</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; centerdistance_xdminus1(image, 2)</span>
<span class="sd">    </span>
<span class="sd">    Note that the centerdistance of each slice will be equal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pre-process arguments</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        
    <span class="c1"># check arguments</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ArgumentError</span><span class="p">(</span><span class="s1">&#39;Applying a sub-volume extraction of depth {} on a image of dimensionality {} would lead to invalid images of dimensionality &lt;= 1.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">&gt;=</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ArgumentError</span><span class="p">(</span><span class="s1">&#39;Invalid dimension index {} supplied for image(s) of shape {}.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    
    <span class="c1"># extract desired sub-volume</span>
    <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span> <span class="n">slicer</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">subvolume</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">slicer</span><span class="p">])</span>
    
    <span class="c1"># compute centerdistance for sub-volume and reshape to original sub-volume shape (note that normalization and mask are not passed on in this step)</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">centerdistance</span><span class="p">(</span><span class="n">subvolume</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">subvolume</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    
    <span class="c1"># re-establish original shape by copying the resulting array multiple times</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dims</span><span class="p">):</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">o</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        
    <span class="c1"># extract intensities / centerdistance values, applying normalization and mask in this step</span>
    <span class="k">return</span> <span class="n">intensities</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span></div>

<div class="viewcode-block" id="indices"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.indices.html#medpy.features.intensity.indices">[docs]</a><span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Takes an image and returns the voxels ndim-indices as voxel-wise feature. The voxel</span>
<span class="sd">    spacing is taken into account, i.e. the indices are not array indices, but millimeter</span>
<span class="sd">    indices.</span>
<span class="sd">    </span>
<span class="sd">    This is a multi-element feature where each element corresponds to one of the images</span>
<span class="sd">    axes, e.g. x, y, z, ...</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image. </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : ndarray</span>
<span class="sd">        Each voxels ndimensional index.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This feature is independent of the actual image content, but depends</span>
<span class="sd">    solely on its shape. Therefore always a one-dimensional feature is returned, even if</span>
<span class="sd">    a multi-spectral image has been supplied.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">voxelspacing</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">voxelspacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">vs</span><span class="p">):</span> <span class="n">a</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="n">vs</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">voxelspacing</span><span class="p">)))</span></div>
    
<div class="viewcode-block" id="shifted_mean_gauss"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.shifted_mean_gauss.html#medpy.features.intensity.shifted_mean_gauss">[docs]</a><span class="k">def</span> <span class="nf">shifted_mean_gauss</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    The approximate mean over a small region at an offset from each voxel.</span>
<span class="sd">    </span>
<span class="sd">    Functions like `local_mean_gauss`, but instead of computing the average over a small</span>
<span class="sd">    patch around the current voxel, the region is centered at an offset away. Can be used</span>
<span class="sd">    to use a distant regions average as feature for a voxel.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    offset : sequence of ints</span>
<span class="sd">        At this offset in voxels of the current position the region is placed.</span>
<span class="sd">    sigma : number or sequence of numbers</span>
<span class="sd">        Standard deviation for Gaussian kernel. The standard deviations of the</span>
<span class="sd">        Gaussian filter are given for each axis as a sequence, or as a single number,</span>
<span class="sd">        in which case it is equal for all axes. Note that the voxel spacing of the image</span>
<span class="sd">        is taken into account, the given values are treated as mm.</span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image. </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shifted_mean_gauss : ndarray</span>
<span class="sd">        The weighted mean intensities over a region at offset away from each voxel.</span>
<span class="sd">    </span>
<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    local_mean_gauss</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_shifted_mean_gauss</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="n">voxelspacing</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="mask_distance"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.mask_distance.html#medpy.features.intensity.mask_distance">[docs]</a><span class="k">def</span> <span class="nf">mask_distance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Computes the distance of each point under the mask to the mask border taking the</span>
<span class="sd">    voxel-spacing into account.</span>
<span class="sd">    </span>
<span class="sd">    Note that this feature is independent of the actual image content, but depends</span>
<span class="sd">    solely the mask image. Therefore always a one-dimensional feature is returned,</span>
<span class="sd">    even if a multi-spectral image has been supplied.</span>
<span class="sd">    </span>
<span class="sd">    If no mask has been supplied, the distances to the image borders are returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.     </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask_distance : ndarray</span>
<span class="sd">        Each voxels distance to the mask borders.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">_extract_mask_distance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="n">voxelspacing</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="local_mean_gauss"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.local_mean_gauss.html#medpy.features.intensity.local_mean_gauss">[docs]</a><span class="k">def</span> <span class="nf">local_mean_gauss</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Takes a simple or multi-spectral image and returns the approximate mean over a small</span>
<span class="sd">    region around each voxel. A multi-spectral image must be supplied as a list or tuple</span>
<span class="sd">    of its spectra.</span>
<span class="sd">    </span>
<span class="sd">    Optionally a binary mask can be supplied to select the voxels for which the feature</span>
<span class="sd">    should be extracted.</span>
<span class="sd">    </span>
<span class="sd">    For this feature a Gaussian smoothing filter is applied to the image / each spectrum</span>
<span class="sd">    and then the resulting intensity values returned. Another name for this function</span>
<span class="sd">    would be weighted local mean.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    sigma : number or sequence of numbers</span>
<span class="sd">        Standard deviation for Gaussian kernel. The standard deviations of the</span>
<span class="sd">        Gaussian filter are given for each axis as a sequence, or as a single number,</span>
<span class="sd">        in which case it is equal for all axes. Note that the voxel spacing of the image</span>
<span class="sd">        is taken into account, the given values are treated as mm.        </span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.       </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    local_mean_gauss : ndarray</span>
<span class="sd">        The weighted mean intensities over a region around each voxel.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_local_mean_gauss</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="n">voxelspacing</span><span class="p">)</span></div>

<div class="viewcode-block" id="gaussian_gradient_magnitude"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.gaussian_gradient_magnitude.html#medpy.features.intensity.gaussian_gradient_magnitude">[docs]</a><span class="k">def</span> <span class="nf">gaussian_gradient_magnitude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Computes the gradient magnitude (edge-detection) of the supplied image using gaussian</span>
<span class="sd">    derivates and returns the intensity values.</span>
<span class="sd">    </span>
<span class="sd">    Optionally a binary mask can be supplied to select the voxels for which the feature</span>
<span class="sd">    should be extracted.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    sigma : number or sequence of numbers</span>
<span class="sd">        Standard deviation for Gaussian kernel. The standard deviations of the</span>
<span class="sd">        Gaussian filter are given for each axis as a sequence, or as a single number,</span>
<span class="sd">        in which case it is equal for all axes. Note that the voxel spacing of the image</span>
<span class="sd">        is taken into account, the given values are treated as mm.        </span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.          </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gaussian_gradient_magnitude : ndarray</span>
<span class="sd">        The gaussian gradient magnitude of the supplied image.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_gaussian_gradient_magnitude</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="n">voxelspacing</span><span class="p">)</span></div>

<div class="viewcode-block" id="median"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.median.html#medpy.features.intensity.median">[docs]</a><span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the multi-dimensional median filter and returns the resulting values per</span>
<span class="sd">    voxel.</span>
<span class="sd">    </span>
<span class="sd">    Optionally a binary mask can be supplied to select the voxels for which the feature</span>
<span class="sd">    should be extracted.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    size : number or sequence of numbers</span>
<span class="sd">        Size of the structuring element. Can be given given for each axis as a sequence,</span>
<span class="sd">        or as a single number, in which case it is equal for all axes. Note that the</span>
<span class="sd">        voxel spacing of the image is taken into account, the given values are treated</span>
<span class="sd">        as mm.</span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    median : ndarray</span>
<span class="sd">        Multi-dimesnional median filtered version of the input images.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_median</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="n">voxelspacing</span><span class="p">)</span></div>

<div class="viewcode-block" id="local_histogram"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.local_histogram.html#medpy.features.intensity.local_histogram">[docs]</a><span class="k">def</span> <span class="nf">local_histogram</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">19</span><span class="p">,</span> <span class="n">rang</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="n">cutoffp</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Computes multi-dimensional histograms over a region around each voxel.</span>
<span class="sd">    </span>
<span class="sd">    Supply an image and (optionally) a mask and get the local histogram of local</span>
<span class="sd">    neighbourhoods around each voxel. These neighbourhoods are cubic with a sidelength of</span>
<span class="sd">    size in voxels or, when a shape instead of an integer is passed to size, of this</span>
<span class="sd">    shape.</span>
<span class="sd">    </span>
<span class="sd">    If not argument is passed to output, the returned array will be of dtype float.</span>
<span class="sd">    </span>
<span class="sd">    Voxels along the image border are treated as defined by mode. The possible values are</span>
<span class="sd">    the same as for scipy.ndimage filter without the &#39;&#39;constant&#39;&#39; mode. Instead &quot;ignore&quot;</span>
<span class="sd">    is the default and additional mode, which sets that the area outside of the image are</span>
<span class="sd">    ignored when computing the histogram.</span>
<span class="sd">    </span>
<span class="sd">    When a mask is supplied, the local histogram is extracted only for the voxels where</span>
<span class="sd">    the mask is True. But voxels from outside the mask can be incorporated in the</span>
<span class="sd">    compuation of the histograms.</span>
<span class="sd">    </span>
<span class="sd">    The range of the histograms can be set via the rang argument. The &#39;image&#39; keyword can</span>
<span class="sd">    be supplied, to use the same range for all local histograms, extracted from the images</span>
<span class="sd">    max and min intensity values. Alternatively, an own range can be supplied in the form</span>
<span class="sd">    of a tuple of two numbers. Values outside the range of the histogram are ignored.</span>
<span class="sd">    </span>
<span class="sd">    Setting a proper range is important, as all voxels that lie outside of the range are</span>
<span class="sd">    ignored i.e. do not contribute to the histograms as if they would not exists. Some</span>
<span class="sd">    of the local histograms can therefore be constructed from less than the expected</span>
<span class="sd">    number of voxels.</span>
<span class="sd">    </span>
<span class="sd">    Taking the histogram range from the whole image is sensitive to outliers. Supplying</span>
<span class="sd">    percentile values to the cutoffp argument, these can be filtered out when computing</span>
<span class="sd">    the range. This keyword is ignored if rang is not set to &#39;image&#39;.</span>
<span class="sd">    </span>
<span class="sd">    Setting the rang to None causes local ranges to be used i.e. the ranges of the</span>
<span class="sd">    histograms are computed only over the local area covered by them and are hence</span>
<span class="sd">    not comparable. This behaviour should normally not be taken.</span>
<span class="sd">    </span>
<span class="sd">    The local histograms are normalized by dividing them through the number of elements</span>
<span class="sd">    in the bins.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    bins : integer</span>
<span class="sd">        The number of histogram bins.</span>
<span class="sd">    rang : &#39;image&#39; or tuple of numbers or None</span>
<span class="sd">        The range of the histograms, can be supplied manually, set to &#39;image&#39; to use</span>
<span class="sd">        global or set to None to use local ranges.</span>
<span class="sd">    cutoffp : tuple of numbers</span>
<span class="sd">        The cut-off percentiles to exclude outliers, only processed if ``rang`` is set</span>
<span class="sd">        to &#39;image&#39;.</span>
<span class="sd">    size : scalar or tuple of integers</span>
<span class="sd">        See footprint, below</span>
<span class="sd">    footprint : array</span>
<span class="sd">        Either ``size`` or ``footprint`` must be defined. ``size`` gives the shape that</span>
<span class="sd">        is taken from the input array, at every element position, to define the input to</span>
<span class="sd">        the filter function. ``footprint`` is a boolean array that specifies (implicitly)</span>
<span class="sd">        a shape, but also which of the elements within this shape will get passed to the</span>
<span class="sd">        filter function. Thus ``size=(n,m)`` is equivalent to</span>
<span class="sd">        ``footprint=np.ones((n,m))``. We adjust ``size`` to the number of dimensions of</span>
<span class="sd">        the input array, so that, if the input array is shape (10,10,10), and ``size``</span>
<span class="sd">        is 2, then the actual size used is (2,2,2).</span>
<span class="sd">    output ndarray or dtype</span>
<span class="sd">        The ``output`` parameter passes an array in which to store the filter output.</span>
<span class="sd">    mode : {&#39;reflect&#39;, &#39;ignore&#39;, &#39;nearest&#39;, &#39;mirror&#39;, &#39;wrap&#39;}</span>
<span class="sd">        The ``mode`` parameter determines how the array borders are handled. Default is &#39;ignore&#39;</span>
<span class="sd">    origin : number</span>
<span class="sd">        The ``origin`` parameter controls the placement of the filter. Default 0.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    local_histogram : ndarray</span>
<span class="sd">        The bin values of the local histograms for each voxel as a multi-dimensional image.</span>

<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_local_histogram</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="n">rang</span><span class="o">=</span><span class="n">rang</span><span class="p">,</span> <span class="n">cutoffp</span><span class="o">=</span><span class="n">cutoffp</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span></div>


<div class="viewcode-block" id="hemispheric_difference"><a class="viewcode-back" href="../../../generated/medpy.features.intensity.hemispheric_difference.html#medpy.features.intensity.hemispheric_difference">[docs]</a><span class="k">def</span> <span class="nf">hemispheric_difference</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma_active</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">sigma_reference</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">cut_plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">    Computes the hemispheric intensity difference between the brain hemispheres of an brain image.</span>
<span class="sd">    </span>
<span class="sd">    Cuts the image along the middle of the supplied cut-plane. This results in two</span>
<span class="sd">    images, each containing one of the brains hemispheres.</span>
<span class="sd">    </span>
<span class="sd">    For each of these two, the following steps are applied:</span>
<span class="sd">    </span>
<span class="sd">    1. One image is marked as active image</span>
<span class="sd">    2. The other hemisphere image is marked as reference image</span>
<span class="sd">    3. The reference image is fliped along the cut_plane</span>
<span class="sd">    4. A gaussian smoothing is applied to the active image with the supplied sigma</span>
<span class="sd">    5. A gaussian smoothing is applied to the reference image with the supplied sigma</span>
<span class="sd">    6. The reference image is substracted from the active image, resulting in the</span>
<span class="sd">       difference image for the active hemisphere</span>
<span class="sd">    </span>
<span class="sd">    Finally, the two resulting difference images are stitched back together, forming a</span>
<span class="sd">    hemispheric difference image of the same size as the original.</span>
<span class="sd">    </span>
<span class="sd">    Note that the supplied gaussian kernel sizes (sigmas) are sensitive to the images</span>
<span class="sd">    voxel spacing.</span>
<span class="sd">    </span>
<span class="sd">    If the number of slices along the cut-plane is odd, the central slice is</span>
<span class="sd">    interpolated from the two hemisphere difference images when stitching them back</span>
<span class="sd">    together.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    sigma_active : number or sequence of numbers</span>
<span class="sd">        Standard deviation for Gaussian kernel of the active image. The standard</span>
<span class="sd">        deviations of the Gaussian filter are given for each axis as a sequence, or as a</span>
<span class="sd">        single number, in which case it is equal for all axes. Note that the voxel</span>
<span class="sd">        spacing of the image is taken into account, the given values are treated</span>
<span class="sd">        as mm.</span>
<span class="sd">    sigma_reference : number or sequence of numbers</span>
<span class="sd">        Standard deviation for Gaussian kernel of the reference image. The standard</span>
<span class="sd">        deviations of the Gaussian filter are given for each axis as a sequence, or as a</span>
<span class="sd">        single number, in which case it is equal for all axes. Note that the voxel</span>
<span class="sd">        spacing of the image is taken into account, the given values are treated</span>
<span class="sd">        as mm.</span>
<span class="sd">    cut_plane : integer</span>
<span class="sd">        he axes along which to cut. This is usually the coronal plane.</span>
<span class="sd">    voxelspacing : sequence of floats</span>
<span class="sd">        The side-length of each voxel.</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        A binary mask for the image.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hemispheric_difference : ndarray</span>
<span class="sd">        The intensity differences between the locally smoothed hemispheres of the image.</span>
<span class="sd">        The resulting voxel value&#39;s magnitude denotes symmetrical its asymmetry. The</span>
<span class="sd">        direction is revealed by the sign. That means that the resulting image will be</span>
<span class="sd">        symmetric in absolute values, but differ in sign. </span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ArgumentError</span>
<span class="sd">        If the supplied cut-plane dimension is invalid.</span>

<span class="sd">    &quot;&quot;&quot;</span>   
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_hemispheric_difference</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sigma_active</span> <span class="o">=</span> <span class="n">sigma_active</span><span class="p">,</span> <span class="n">sigma_reference</span> <span class="o">=</span> <span class="n">sigma_reference</span><span class="p">,</span> <span class="n">cut_plane</span> <span class="o">=</span> <span class="n">cut_plane</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="n">voxelspacing</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_extract_hemispheric_difference</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">sigma_active</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">sigma_reference</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">cut_plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of `hemispheric_difference`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># constants</span>
    <span class="n">INTERPOLATION_RANGE</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># how many neighbouring values to take into account when interpolating the medial longitudinal fissure slice</span>
    
    <span class="c1"># check arguments</span>
    <span class="k">if</span> <span class="n">cut_plane</span> <span class="o">&gt;=</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ArgumentError</span><span class="p">(</span><span class="s1">&#39;The suppliedc cut-plane ({}) is invalid, the image has only {} dimensions.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cut_plane</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    
    <span class="c1"># set voxel spacing</span>
    <span class="k">if</span> <span class="n">voxelspacing</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">voxelspacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
    
    <span class="c1"># compute the (presumed) location of the medial longitudinal fissure, treating also the special of an odd number of slices, in which case a cut into two equal halves is not possible</span>
    <span class="n">medial_longitudinal_fissure</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">medial_longitudinal_fissure_excluded</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span>
    
    <span class="c1"># split the head into a dexter and sinister half along the saggital plane</span>
    <span class="c1"># this is assumed to be consistent with a cut of the brain along the medial longitudinal fissure, thus separating it into its hemispheres</span>
    <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">slicer</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">medial_longitudinal_fissure</span><span class="p">)</span>
    <span class="n">left_hemisphere</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>

    <span class="n">slicer</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">medial_longitudinal_fissure</span> <span class="o">+</span> <span class="n">medial_longitudinal_fissure_excluded</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">right_hemisphere</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>
    
    <span class="c1"># flip right hemisphere image along cut plane</span>
    <span class="n">slicer</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">right_hemisphere</span> <span class="o">=</span> <span class="n">right_hemisphere</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>

    <span class="c1"># substract once left from right and once right from left hemisphere, including smoothing steps</span>
    <span class="n">right_hemisphere_difference</span> <span class="o">=</span> <span class="n">_substract_hemispheres</span><span class="p">(</span><span class="n">right_hemisphere</span><span class="p">,</span> <span class="n">left_hemisphere</span><span class="p">,</span> <span class="n">sigma_active</span><span class="p">,</span> <span class="n">sigma_reference</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">)</span>
    <span class="n">left_hemisphere_difference</span> <span class="o">=</span> <span class="n">_substract_hemispheres</span><span class="p">(</span><span class="n">left_hemisphere</span><span class="p">,</span> <span class="n">right_hemisphere</span><span class="p">,</span> <span class="n">sigma_active</span><span class="p">,</span> <span class="n">sigma_reference</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">)</span>
    
    <span class="c1"># re-flip right hemisphere image to original orientation</span>
    <span class="n">right_hemisphere_difference</span> <span class="o">=</span> <span class="n">right_hemisphere_difference</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>
    
    <span class="c1"># estimate the medial longitudinal fissure if required</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">medial_longitudinal_fissure_excluded</span><span class="p">:</span>
        <span class="n">left_slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">right_slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">left_slicer</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">INTERPOLATION_RANGE</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">right_slicer</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">INTERPOLATION_RANGE</span><span class="p">)</span>
        <span class="n">interp_data_left</span> <span class="o">=</span> <span class="n">left_hemisphere_difference</span><span class="p">[</span><span class="n">left_slicer</span><span class="p">]</span>
        <span class="n">interp_data_right</span> <span class="o">=</span> <span class="n">right_hemisphere_difference</span><span class="p">[</span><span class="n">right_slicer</span><span class="p">]</span>
        <span class="n">interp_indices_left</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">interp_data_left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">interp_indices_right</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">interp_data_right</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">interp_data</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">left_hemisphere_difference</span><span class="p">[</span><span class="n">left_slicer</span><span class="p">],</span> <span class="n">right_hemisphere_difference</span><span class="p">[</span><span class="n">right_slicer</span><span class="p">]),</span> <span class="n">cut_plane</span><span class="p">)</span>
        <span class="n">interp_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">interp_indices_left</span><span class="p">,</span> <span class="n">interp_indices_right</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">medial_longitudinal_fissure_estimated</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">interp_indices</span><span class="p">,</span> <span class="n">interp_data</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">cut_plane</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># add singleton dimension</span>
        <span class="n">slicer</span><span class="p">[</span><span class="n">cut_plane</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span>
        <span class="n">medial_longitudinal_fissure_estimated</span> <span class="o">=</span> <span class="n">medial_longitudinal_fissure_estimated</span><span class="p">[</span><span class="n">slicer</span><span class="p">]</span>

    <span class="c1"># stich images back together</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">medial_longitudinal_fissure_excluded</span><span class="p">:</span>
        <span class="n">hemisphere_difference</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">left_hemisphere_difference</span><span class="p">,</span> <span class="n">medial_longitudinal_fissure_estimated</span><span class="p">,</span> <span class="n">right_hemisphere_difference</span><span class="p">),</span> <span class="n">cut_plane</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hemisphere_difference</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">left_hemisphere_difference</span><span class="p">,</span> <span class="n">right_hemisphere_difference</span><span class="p">),</span> <span class="n">cut_plane</span><span class="p">)</span>

    <span class="c1"># extract intensities and return</span>
    <span class="k">return</span> <span class="n">_extract_intensities</span><span class="p">(</span><span class="n">hemisphere_difference</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_extract_local_histogram</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">19</span><span class="p">,</span> <span class="n">rang</span><span class="o">=</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="n">cutoffp</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of @see local_histogram</span>
<span class="sd">    </span>
<span class="sd">    Note: Values outside of the histograms range are not considered.</span>
<span class="sd">    Note: Mode constant is not available, instead a mode &quot;ignore&quot; is provided.</span>
<span class="sd">    Note: Default dtype of returned values is float.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;constant&quot;</span> <span class="o">==</span> <span class="n">mode</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;boundary mode not supported&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;ignore&quot;</span> <span class="o">==</span> <span class="n">mode</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;image&#39;</span> <span class="o">==</span> <span class="n">rang</span><span class="p">:</span>
        <span class="n">rang</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">cutoffp</span><span class="p">))</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="mi">2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rang</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;the rang must contain exactly two elements or the string &quot;image&quot;&#39;</span><span class="p">)</span>
        
    <span class="n">_</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">histogram</span><span class="p">([],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">rang</span><span class="p">)</span>
    <span class="n">output</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_get_output</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span> <span class="k">if</span> <span class="bp">None</span> <span class="o">==</span> <span class="n">output</span> <span class="k">else</span> <span class="n">output</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">bins</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

    <span class="c1"># threshold the image into the histogram bins represented by the output images first dimension, treat last bin separately, since upper border is inclusive</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bins</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span> <span class="o">&gt;=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">image</span> <span class="o">&lt;</span> <span class="n">bin_edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span> <span class="o">&gt;=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">image</span> <span class="o">&lt;=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># apply the sum filter to each dimension, then normalize by dividing through the sum of elements in the bins of each histogram</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
        <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_filter</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>
    <span class="n">divident</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">divident</span><span class="p">[</span><span class="mi">0</span> <span class="o">==</span> <span class="n">divident</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">output</span> <span class="o">/=</span> <span class="n">divident</span>
    
    <span class="c1"># Notes on modes:</span>
    <span class="c1"># mode=constant with a cval outside histogram range for the histogram equals a mode=constant with a cval = 0 for the sum_filter</span>
    <span class="c1"># mode=constant with a cval inside  histogram range for the histogram has no equal for the sum_filter (and does not make much sense)</span>
    <span class="c1"># mode=X for the histogram equals mode=X for the sum_filter</span>

    <span class="c1"># treat as multi-spectral image which intensities to extracted</span>
    <span class="k">return</span> <span class="n">_extract_feature</span><span class="p">(</span><span class="n">_extract_intensities</span><span class="p">,</span> <span class="p">[</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">output</span><span class="p">],</span> <span class="n">mask</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_extract_median</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of `median`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set voxel spacing</span>
    <span class="k">if</span> <span class="n">voxelspacing</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">voxelspacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
        
    <span class="c1"># determine structure element size in voxel units</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">_create_structure_array</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">_extract_intensities</span><span class="p">(</span><span class="n">median_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span> <span class="n">mask</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_extract_gaussian_gradient_magnitude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of `gaussian_gradient_magnitude`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set voxel spacing</span>
    <span class="k">if</span> <span class="n">voxelspacing</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">voxelspacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
        
    <span class="c1"># determine gaussian kernel size in voxel units</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">_create_structure_array</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">_extract_intensities</span><span class="p">(</span><span class="n">scipy_gaussian_gradient_magnitude</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span><span class="p">),</span> <span class="n">mask</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_extract_shifted_mean_gauss</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">offset</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of `shifted_mean_gauss`.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="c1"># set voxel spacing</span>
    <span class="k">if</span> <span class="n">voxelspacing</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">voxelspacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
    <span class="c1"># set offset</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
    
    <span class="c1"># determine gaussian kernel size in voxel units</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">_create_structure_array</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">)</span>
    
    <span class="c1"># compute smoothed version of image</span>
    <span class="n">smoothed</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
    
    <span class="n">shifted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">smoothed</span><span class="p">)</span>
    <span class="n">in_slicer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out_slicer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">offset</span><span class="p">:</span>
        <span class="n">in_slicer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
        <span class="n">out_slicer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">o</span><span class="p">))</span>
    <span class="n">shifted</span><span class="p">[</span><span class="n">out_slicer</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothed</span><span class="p">[</span><span class="n">in_slicer</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">_extract_intensities</span><span class="p">(</span><span class="n">shifted</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_extract_mask_distance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of `mask_distance`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    
    <span class="n">distance_map</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">sampling</span><span class="o">=</span><span class="n">voxelspacing</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">_extract_intensities</span><span class="p">(</span><span class="n">distance_map</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">_extract_local_mean_gauss</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">sigma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of `local_mean_gauss`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set voxel spacing</span>
    <span class="k">if</span> <span class="n">voxelspacing</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">voxelspacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
        
    <span class="c1"># determine gaussian kernel size in voxel units</span>
    <span class="n">sigma</span> <span class="o">=</span> <span class="n">_create_structure_array</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">_extract_intensities</span><span class="p">(</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span><span class="p">),</span> <span class="n">mask</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_extract_centerdistance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="n">voxelspacing</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of `centerdistance`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="bp">None</span> <span class="o">==</span> <span class="n">voxelspacing</span><span class="p">:</span>
        <span class="n">voxelspacing</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span>
        
    <span class="c1"># get image center and an array holding the images indices</span>
    <span class="n">centers</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    
    <span class="c1"># shift to center of image and correct spacing to real world coordinates</span>
    <span class="k">for</span> <span class="n">dim_indices</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">centers</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">):</span>
        <span class="n">dim_indices</span> <span class="o">-=</span> <span class="n">c</span>
        <span class="n">dim_indices</span> <span class="o">*=</span> <span class="n">vs</span>
        
    <span class="c1"># compute euclidean distance to image center</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="mi">0</span><span class="p">))[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    

<span class="k">def</span> <span class="nf">_extract_intensities</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal, single-image version of `intensities`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_substract_hemispheres</span><span class="p">(</span><span class="n">active</span><span class="p">,</span> <span class="n">reference</span><span class="p">,</span> <span class="n">active_sigma</span><span class="p">,</span> <span class="n">reference_sigma</span><span class="p">,</span> <span class="n">voxel_spacing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function for `_extract_hemispheric_difference`.</span>
<span class="sd">    Smoothes both images and then substracts the reference from the active image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">active_kernel</span> <span class="o">=</span> <span class="n">_create_structure_array</span><span class="p">(</span><span class="n">active_sigma</span><span class="p">,</span> <span class="n">voxel_spacing</span><span class="p">)</span>
    <span class="n">active_smoothed</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">active</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">active_kernel</span><span class="p">)</span>

    <span class="n">reference_kernel</span> <span class="o">=</span> <span class="n">_create_structure_array</span><span class="p">(</span><span class="n">reference_sigma</span><span class="p">,</span> <span class="n">voxel_spacing</span><span class="p">)</span>
    <span class="n">reference_smoothed</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">sigma</span> <span class="o">=</span> <span class="n">reference_kernel</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">active_smoothed</span> <span class="o">-</span> <span class="n">reference_smoothed</span>

<span class="k">def</span> <span class="nf">_create_structure_array</span><span class="p">(</span><span class="n">structure_array</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenient function to take a structure array (single number valid for all dimensions</span>
<span class="sd">    or a sequence with a distinct number for each dimension) assumed to be in mm and</span>
<span class="sd">    returns a structure array (a sequence) adapted to the image space using the supplied</span>
<span class="sd">    voxel spacing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">structure_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">vs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">structure_array</span><span class="p">,</span> <span class="n">voxelspacing</span><span class="p">)]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">structure_array</span> <span class="o">=</span> <span class="p">[</span><span class="n">structure_array</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">vs</span><span class="p">)</span> <span class="k">for</span> <span class="n">vs</span> <span class="ow">in</span> <span class="n">voxelspacing</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">structure_array</span>    

<span class="k">def</span> <span class="nf">_extract_feature</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convenient function to cope with multi-spectral images and feature normalization.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fun : function</span>
<span class="sd">        The feature extraction function to call</span>
<span class="sd">    image : array_like or list/tuple of array_like </span>
<span class="sd">        A single image or a list/tuple of images (for multi-spectral case).</span>
<span class="sd">    mask : ndarray</span>
<span class="sd">        The binary mask to select the voxels for which to extract the feature</span>
<span class="sd">    kwargs : sequence</span>
<span class="sd">        Additional keyword arguments to be passed to the feature extraction function </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">slice</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">join</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">fun</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">image</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

          </div>
        </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container container-navbar-bottom">
      <div class="spc-navbar">
        
      </div>
    </div>
    <div class="container">
    <div class="footer">
    <div class="row-fluid">
    <ul class="inline pull-left">
      <li>
        &copy; Copyright 2016, Oskar Maier.
      </li>
      <li>
      Last updated on Sep 20, 2017.
      </li>
      <li>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.4.
      </li>
    </ul>
    </div>
    </div>
    </div>
  </body>
</html>
